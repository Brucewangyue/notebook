## 数组元素交换

```java
public static void swap(int[] arr,int i,int j){
    // 普通方式
    // int temp = arr[i];
    // arr[i] = arr[j];
    // arr[j] = temp;
    
    // 不使用临时变量方式
    arr[i] = arr[i] + arr[j];
    arr[j] = arr[i] - arr[j];
    arr[i] = arr[i] - arr[j];
    
    // 位运算方式
}
```



## 选择排序

- 在给定边界内，每次选择一个最小的值放入排序队列

1. 从0到N-1中选择最小值放在0位置
2. 从1到N-1中选择最小值放在1位置
3. 从2到N-1中选择最小值放在2位置
4. ...

```java
static void selectionSort(int[] arr) {
    // 首先确定边界条件
    if (arr == null || arr.length < 2)
        return;
    
    int N = arr.length;
    // 0 ~ n-1
    // 1 ~ n-1
    // 2 ~ n-1
    // 3 ~ n-1
    for (int i = 0; i < N; i++) {
        // i ~ n-1
        int minValueIndex = i;
        for (int j = i + 1; j < N; j++) {
            minValueIndex = arr[j] < arr[minValueIndex] ? j : minValueIndex;
      
        swap(arr, i, minValueIndex);
    }
}
```

## 冒泡排序

- 左右比较，如果左边大则交换位置
- 每一轮循环后可以确认一个最大值

```java
static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2)
            return;
        // 0 ~ n-1
        // 0 ~ n-2
        // 0 ~ n-3
        // 0 ~ end
        int N = arr.length;
//        for (int i = 0; i < N; i++) {
//            // 01 12 23 34 45 (end-1 end) 比较交换
//            for (int second = 1; second < N - i; second++) {
//                if (arr[second - 1] > arr[second])
//                    swap(arr, second - 1, second);
//            }
//        }
        for (int end = N - 1; end >= 0; end--) {
            for (int second = 1; second <= end; second++) {
                if (arr[second - 1] > arr[second])
                    swap(arr, second - 1, second);
            }
        }
    }
```

## 插入排序

```java
static void insertSort1(int[] arr) {
    if (arr == null || arr.length < 2)
        return;
    //0 ~ 0
    //0 ~ 1
    //0 ~ 2
    //0 ~ 3
    //0 ~ n-1 范围内有序
    int N = arr.length;
    for (int end = 0; end < N; end++) {
        int newNumIndex = end;
        while (newNumIndex - 1 >= 0 && arr[newNumIndex] < arr[newNumIndex - 1]) {
            swap(arr, newNumIndex, newNumIndex - 1);
            // 往前移动
            newNumIndex--;
        }
    }
}

static void insertSort2(int[] arr) {
    if (arr == null || arr.length < 2)
        return;
    int N = arr.length;
    for (int end = 0; end < N; end++) {
        for (int pre = end - 1; pre >= 0 && arr[pre] > arr[pre + 1]; pre--) {
            swap(arr, pre, pre + 1);
        }
    }
}
```

## 快速排序

