树

树是一种抽象数据类型（ADT）

树的类型：

多路树：一个节点有多于两个的子节点的树

二叉树：每个节点最多只能有2个子节点的树

二叉树种类：完美二叉树(满二叉树)，完全二叉树，完满二叉树

二叉搜索树：

能使用二分查找算法、拥有链表的快速插入



二分查找算法（依赖于有序数组）

[1,2,3,4,...100]

每次取中间数判断

```java
public int binarySearch(int[] arr,int data){
    // 起始区间
    int low = 0;
    // 结束区间
    int height = arr.length - 1;
    while(low<=height){
        // (height - low)  ...  + low  是当减去小于中间的一半后
        int mid = (height - low) / 2 + low;
        if(arr[mid] > data){
            height = mid-1;
        }else if(arr[mid] == data){
            return mid;
        }else{
            low = mid + 1;
        }
    }
    
    return -1;
}
```



时间复杂度

推算过程

| 查询次数 | 剩余要查询的元素个数 |
| -------- | -------------------- |
| 1        | n/2                  |
| 2        | n/(2^2)              |
| 3        | n/(2^3)              |
| k        | n/(2^k)              |

按照表格推算，n/(2^k)肯定是大于等于1（如果不大于1那就结束不需要查了）

得：n/(2^k) = 1

得：n = 2^k

得：k = log2(n)

得：k = logN

时间复杂度为：O(logN)



普通二叉搜索树的缺陷：子节点链表化，时间复杂度退化成O(N)

如果插入数据时，树可以自动调整两边的平衡，会保持不错的性能 



AVL树

每个节点的左子树和右子树高度差至多等于1



缺陷：高度差设定不能大于1，导致插入/删除节点的操作，经常都要调整（左旋、右旋）树的结构，使之符合平衡树的规范

如果插入/删除节点的操作很频繁，那么性能会大打折扣，为了解决这个问题，就有了红黑树



红黑树  
[一篇介绍红黑树的博客](https://blog.csdn.net/chen_zhang_yu/article/details/52415077?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2)

黑色完美平衡树

平衡的方式：左旋、右旋、变色

变色：黑边红、红变黑

左旋：以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变

右旋：以某个节点作为支点（）

插入：
都是以红色节点插入，因为黑色节点插入是一定破坏黑色完美平衡，红色节点插入有可能不会破坏

插入后如果出现红红相连，则通过左旋或者右旋，或者多次旋转后达到平衡