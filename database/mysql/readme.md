# MySQL



## 安装

**Mysql安装文档参考**：https://blog.csdn.net/yougoule/article/details/56680952 

## [内部原理](内部原理.md)



## [数据类型](数据类型.md)



## 索引

**索引是排好序的数据结构，帮助MySQL高效查询数据**

- **数据结构**

  - 二叉树

    - 左小右大

      ![image-20220109140235115](assets/image-20220109140235115.png)

    - 当节点按循序插入数据时，变成了链表，查询速度是O(n)

      ![image-20220106004757755](assets/image-20220106004757755.png)

  - 红黑树

    ![image-20220106004815757](assets/image-20220106004815757.png)

  - Hash表（数组+链表）

    - 对索引的key进行一次hash计算就可以定位出数据存储的位置
    - 很多时候Hash索引要比B+ 树索引更高效
    - 仅能满足 “=”，“IN”，不支持范围查询
    - hash冲突问题

    ![image-20220109141008415](assets/image-20220109141008415.png)

  - B-Tree

    - 叶节点具有相同的深度，叶节点的指针为空，所有索引元素不重复，节点中的数据索引从左到右递增排列![image-20220106004223210](assets/image-20220106004223210.png)

  - **B+Tree**

    - **非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引**

    - **叶子节点包含所有索引字段**
    
    - **叶子节点用指针连接，提高区间访问的性能**
    
  - **一个节点是一个数据页，默认大小是16KB**
    
      ```sh
      假设整个数据页都用BigInter类型64位(8字节)的数据，指向下级的指针是6个字节，那么根节点一个数据页能存放1170个数据，二级节点就是1170个数据页，假设第三级叶子节点的数据是1KB，那么一个数据页存16个数据，最后能得出一个3层深度的B+Tree能存的数据
      117*1170*16 =21,902,400 条
      ```
    
      ![image-20220106004150540](assets/image-20220106004150540.png)

- **索引类型**

  - 聚集索引（主键索引）

    - 叶子节点包含完整的行数据，InnoDB表只会有一份聚集索引，默认使用主键索引来组织

      ![image-20220105235814817](assets/image-20220105235814817.png)

  - 非聚集索引（主键索引）

    - MyISAM引擎的是非聚集索引，索引的叶子节点存放的数据是行数据所在磁盘的地址空间

      ![image-20220109145112502](assets/image-20220109145112502.png)

  - 非主键索引/非聚集索引（次要索引、辅助索引）

    - 非主键索引组织的叶子节点中不包含所有数据，只指向主键索引的数据，然后通过**回表**最后得到数据

      ![image-20220109150126666](assets/image-20220109150126666.png)

  - 联合索引

    - 最左列原理，按制定列的先后顺序建立

    - 一般单个表不建议建立太多的单字段的索引，比如有5个字段，都要作为查询条件，那么要为这5个字段分别建立索引吗？此时可以使用联合索引来优化

      ![image-20220106001553910](assets/image-20220106001553910.png)

    - 索引查询的时候，先按 name 列查询，如果 name 相等，开始对 age 列查询

    - **以下SQL哪条会走索引？**

      ```sql
      key `idx_name_age_position` (`name`,`age`,`position`) USING BTREE
      
      select * from emp where name = 'bill' and age = 31;
      select * from emp where age = 31 and position = 'dev';
      select * from emp where position = 'dev';
      ```

      **只有第一条SQL会走索引，由上图可以看出，age = 30 会在多个数据页中，完全不能用来索引**

  - 覆盖索引

    他并不是真正的索引，只是一种索引方式，如果**辅助索引内包含了所有的要查询的字段数据**则可以说查询使用了**覆盖索引**

    select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引。覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值

## [调优工具](调优工具.md)



## [索引调优 ](索引调优.md)



## [锁机制](锁机制.md)





## 面试题

- **为什么建议InnoDB表必须建主键，并且推荐使用整形的自增主键？**
  - 因为InnoDB引擎的索引存储数据结构是B+Tree，如果表没有建立主键，那么MySQL会选出表的某一列（没有重复数据）来作为B+Tree的索引来组织数据文件，如果选不出来，就会创建一个隐藏的列来组织数据
  - B+Tree是有序的数据结构，如果插入的数据不是按顺序（UUID），B+Tree会经常分裂子节点，还有重新平衡父节点
  
- **B-Tree 和 B+Tree 有什么区别？**
  - B+Tree的叶子节点有头尾指针
  - B+Tree的全部数据存放在叶子节点，最大利用数据页的容量来存放导航索引，并且减少了树的深度
  
- **为什么非主键索引结构叶子节点存储的是主键值？**
  
  - 数据一致性、节省空间
  
- **解决like'%字符串%'索引不被使用的方法？** 

  - 使用覆盖索引，查询字段必须是建立覆盖索引字段 

    ```sql
    EXPLAIN SELECT name,age,position FROM employees WHERE name like '%Lei%';
    ```

    ![image-20220109163837567](assets/image-20220109163837567.png)

  - 如果不能使用覆盖索引则可能需要借助搜索引擎

