# Distributed Transaction



## 二阶段提交 （2PC）

![image-20220124150647416](assets/image-20220124150647416.png)

不能完全解决分布式事务问题，但是会让出错的概率极低

比如在第二阶段通知各个服务提交的时候，其中某个服务刚好在这个阶段宕机（概率极低）

在二阶段整个流程中，所有的RM内的连接资源要保留，否则就不是一个事务了，所以资源占用高

**流程：假设有服务A、服务B**

- 阶段一：
  1. 事务询问：协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各RM的响应
  2. 执行事务：参与者节点执行询问发起的所有事务操作，并将Undo信息和Redo信息写入日志（注意：若成功这里其实每个TM已经执行了事务）
  3. 反馈询问：RM响应TM发起的询问，如果所有RM成功，TM返回“yes”，如果一个以上TM失败，TM返回"cancel"
- 阶段二：
  - 执行事务提交：当TM返回`yes`，RM开始commit，释放事务期间占用的资源
  - 中止事务提交：当TM返回`cancel`，RM开始rollback，参与节点利用之前的undo信息执行回滚，释放事务期间占用的资源

## 三阶段提交

![image-20220124152135152](assets/image-20220124152135152.png)

**流程：假设有服务A、服务B**

1. 程序运行到服务A的分布式事务开启阶段，发送询问消息给TM，看网络是否正常，挂起线程，请求服务B（不占用数据库连接资源）
2. 程序运行到服务B的分布式事务开启阶段，发送询问消息给TM，看网络是否正常
3. TM通知服务A和服务B：yes
4. 服务A收到TM消息，开始运行SQL预提交，并且发送消息给TM（开始占用数据库连接资源）
5. 服务B收到TM消息，开始运行SQL预提交，并且发送消息给TM（开始占用数据库连接资源）
6. TM通知服务A和服务B：docommit
7. 服务A收到TM消息，开始真正SQL提交，并且发送消息给TM
8. 服务B收到TM消息，开始真正SQL提交，并且发送消息给TM

三阶段提交与二阶段提交的差别

1. 三阶段多了超时机制
   - 第二阶段TM超时没收到RM的预提交反馈，TM给RM发中断消息（?? RM怎么给TM反馈）
   - 第三阶段RM超时没收到TM的docommit消息，自动提交
2. 三阶段的第一个阶段解决因个别服务器网络问题而导致的资源占用浪费



## 消息队列+事件表

![image-20220124170209936](assets/image-20220124170209936.png)

- **如果解决消费者重复消费？**

  主键冲突来解决幂等，消费端的本地事件表的id使用生产者端事件表的事件id作为唯一主键

- **定时任务是否必须？** 

  不是必须的，按不同的场景分析

  1. 场景1：第三方系统回调时的事务

     通过定时任务的方式，可以让第三方回调的结果不会因消息发生不成功而浪费

  2. 场景2：内部系统间的事务（推荐）

     最好让业务数据、本地事件表数据、消息发送在同一次内部事务中处理，性能比定时任务高，而且开发更简单，也可以通过第三方调用日志表处理第三方回调时事件的消息浪费问题

- **消息队列没收到ACK就挂了**

  由于有主键冲突，所以下次再次消费也不会成功





















